%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Filename: paper.tex
% Author:   David Oniani
% Modified: December 07, 2019
%  _         _____   __  __
% | |    __ |_   _|__\ \/ /
% | |   / _` || |/ _ \\  /
% | |__| (_| || |  __//  \
% |_____\__,_||_|\___/_/\_\
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document Definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Miscellaneous
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Some Setup
\pagestyle{fancy}
\setlength{\jot}{11pt}
\setlength{\parindent}{0pt}
\newcommand\rtypeof{\mathrel{:}}
\newcommand\ltypeof{\mathrel{::}}
\newcommand\subtype{\mathrel{<:}}
\newcommand\subtypecont{\mathrel{<::}}
\newcommand{\syntax}{\texttt}
\DeclareMathAlphabet{\syntaxvar}{OT1}{cmss}{m}{n}
\DeclareMathAlphabet{\type}{OT1}{pzc}{m}{it}

% PDF information and nice-looking urls
\hypersetup{%
  pdfauthor={David Oniani},
  pdftitle={Type Inference Rules For Container Types in CCL},
  pdfsubject={Programming Languages, Type Theory, Type Inference}
  pdfkeywords={Programming, Languages, Types},
  pdflang={English},
  colorlinks=true,
  linkcolor={black!50!blue},
  citecolor={black!50!blue},
  urlcolor={black!50!blue}
}

% Put a centered header of a footnote size on the top of each page
\chead{Type Inference Rules For Container Types in CCL}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author(s), Title, and Date
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Author(s)
\author{David Oniani\\
        Luther College\\
        \href{mailto:oniada01@luther.edu}{oniada01@luther.edu}}

% Title
\title{\textbf{Type Inference Rules For Container Types in CCL}\\
       \medskip
       \small \textsuperscript{*}The paper is written under the guidance of
       Dr.\ Alan K. Zaring
       (\href{mailto:akzaring@luther.edu}{akzaring@luther.edu}).}

% Date
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beginning of the Document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
\noindent We present the type inference rules introducing the notion of
container types in the CCL programming language. This redesign required a
number of substantial changes to the major aspects of the type system and the
syntax of the language. Two new types $\type{Box}$ and $\type{IBox}$ were
introduced. In addition, two new operators $\subtypecont$ and $\ltypeof$ were
designed for dealing with the new types.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The Box and IBox Types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{The $\type{Box}$ and $\type{IBox}$ Types}

CCL is, by and large, value-based language. This makes it rather difficult to
have types more complex than what already comprises CCL. Besides, this is a
major obstacle for the implementation of heterogenous types such as
heterogenous ordered pair, heterogenous vector types, etc. One possible
solution to this problem is introducing the notion of container types.

\medskip

Container types are boxes which are either mutable or immutable. They wrap the
values allowing the composition of compound types by bringing the higher levels
of abstraction. Mutable and immutable types are represented by types
$\type{Box}$ and the $\type{IBox}$ respectively. If these boxes hold some type
$\type{T}$, then the result of wrapping the type will be $\type{Box(T)}$ or
$\type{IBox(T)}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The <: and <:: Relations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{The $\subtypecont$ Relation}

For expressing relationships between container types, we introduce a new
$\subtypecont$ operator. The sole purpose of this operator is to specify the
relation between two container types. As an example, $\type{T} \subtypecont
\type{U}$ is read as ``container type $\type{T}$ is a subtype of the container
type $\type{U}$.'' We proceed by introducing rules based on the new operator.

\begin{gather}
  \inferrule{\type{}}{\type{Box(Triv)} \subtypecont \type{Box(Triv)}}\\
  \inferrule{\type{}}{\type{Box(Int)} \subtypecont \type{Box(Int)}}
\end{gather}

Rules 1 and 2 specify the reflexive property of the operator on $\type{Triv}$
and $\type{Int}$.

\begin{gather}
  \inferrule{\type{T} \subtypecont \type{Box(U)}}{\type{T} \subtypecont \type{IBox(U)}}\\
  \inferrule{\type{Box(T)} \subtypecont \type{IBox(U)}}{\type{IBox(T)} \subtypecont \type{IBox(U)}}\\
  \inferrule{\type{T} \subtypecont \type{U}}{\type{Ref\ T} \subtype \type{Ref\ U}}
\end{gather}

\medskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The : and :: Relations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{The $\ltypeof$ Relation}

\begin{gather}
  \inferrule{\syntax{triv $\syntaxvar{x}$}}{\syntaxvar{x} \rtypeof \type{Triv}}\\
  \inferrule{\syntax{triv $\syntaxvar{x}$}}{\syntaxvar{x} \ltypeof \type{Box(Triv)}}\\
  \inferrule{\syntax{int $\syntaxvar{x}$}}{\syntaxvar{x} \rtypeof \type{Int}}\\
  \inferrule{\syntax{int $\syntaxvar{x}$}}{\syntaxvar{x} \ltypeof \type{Box(Int)}}\\
  \inferrule{\syntaxvar{x} \ltypeof \type{Box(T)}}{\syntax{immut}\ \syntaxvar{x} \rtypeof \type{T}}\\
  \inferrule{\syntaxvar{x} \ltypeof \type{T}}{\syntax{ref}\ \syntaxvar{x} \rtypeof \type{Ref(T)}}\\
  \inferrule{\syntaxvar{x} \ltypeof \type{T}}{\syntax{ref}\ \syntaxvar{x} \ltypeof \type{Box(Ref(T))}}\\
  \inferrule{\syntaxvar{x} \ltypeof \type{T}}{\syntax{\&}\ \syntaxvar{x} \rtypeof \type{Ref(T)}}\\
  \inferrule{\syntaxvar{x} \rtypeof \type{Ref(Box(T))}}{\syntaxvar{x}\ \syntax{@} \rtypeof \type{T}}\\
  \inferrule{\syntaxvar{x} \rtypeof \type{Ref(IBox(T))}}{\syntaxvar{x}\ \syntax{@} \rtypeof \type{T}}\\
  \inferrule{\syntaxvar{x} \rtypeof \type{Ref(T)}}{\syntaxvar{x}\ \syntax{@} \ltypeof \type{T}}\\
  \inferrule{\syntaxvar{x} \ltypeof \type{T} \\ \syntaxvar{y} \ltypeof \type{U} \\ \type{T} \subtypecont \type{U} \\ \syntaxvar{x} \rtypeof \type{V}}{\syntaxvar{x}\ \syntax{:=}\ \syntaxvar{y} \rtypeof \type{V}}
\end{gather}

$\syntax{x} : \type{T}$ is read as ``expression \syntax{x} is of type
$\type{T}$ and is in an \textit{r-context}.''

$\syntax{x} :: \type{T}$ is read as ``variable \syntax{x} is of type $\type{T}$
and is in an \textit{l-context}.''

The operators could also be referred to as the ``r-type of'' and ``l-type of''
operators.

\medskip

l-context denotes everything that is \textit{assignable} (indicated as a
storable memory).\ r-context, on the other hand, denotes everything that is
\textit{expressible} (can be produced by an expression).

\medskip

There is no r-value (e.g.\ expression) of the type $\type{Box(T)}$.

\medskip

For now, we omit rules for $\type{Con}$ types as they only operate on r-values.

\medskip

For now, we omit rules for $\type{Fun}$ types as they only accept r-values.
Any variable and/or primitive type has both r-value and l-value (when it comes
to primitive types, only r-value). In all cases, the r-value part of the actual
parameter is passed when the function is being called.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Basic Rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Resulting Relationships (A Short List)}

\begin{align*}
  &\syntax{int i}                    &&\to i    &&\to \type{Box(Int)}\\
  &\syntax{immut int ii}             &&\to ii   &&\to \type{IBox(Int)}\\
  &\syntax{ref int ri}               &&\to ri   &&\to \type{Box(Ref(Box(Int)))}\\
  &\syntax{immut ref int iri}        &&\to iri  &&\to \type{IBox(Ref(Box(Int)))}\\
  &\syntax{ref immut int rii}        &&\to rii  &&\to \type{Box(Ref((Immut(Box(Int)))))}\\
  &\syntax{immut ref immut int irii} &&\to irii &&\to \type{IBox(Ref((Immut(Box(Int)))))}
\end{align*}

\medskip

Type $\type{Immut\ Box(Immut\ Box(Int))}$ cannot exist. Nested $\type{Box}$
types are only possible when there is at least one $\type{Ref}$ type.

\begin{gather*}
  \type{Box(Triv)}  \subtype \type{Box(Triv)}\\
  \type{Box(Int)}   \subtype \type{Box(Int)}\\
  \type{Box(Triv)}  \subtype \type{IBox(Triv)}\\
  \type{Box(Int)}   \subtype \type{IBox(Int)}\\
  \type{IBox(Triv)} \subtype \type{IBox(Triv)}\\
  \type{IBox(Int)}  \subtype \type{IBox(Int)}
\end{gather*}

\medskip

All the rules above should work with $\type{Ref}$ types in the similar manner:

\begin{gather*}
  \type{Ref(Box(Triv))}  \subtype \type{Ref(Box(Triv))}\\
  \type{Ref(Box(Int))}   \subtype \type{Ref(Box(Int))}\\
  \type{Ref(Box(Triv))}  \subtype \type{Ref(IBox(Triv))}\\
  \type{Ref(Box(Int))}   \subtype \type{Ref(IBox(Int))}\\
  \type{Ref(IBox(Triv))} \subtype \type{Ref(IBox(Triv))}\\
  \type{Ref(IBox(Int))}  \subtype \type{Ref(IBox(Int))}
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The End of the Document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
